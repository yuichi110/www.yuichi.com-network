# スイッチを使った同一ネットワーク内の通信

{{ TOC }}

L2転送
 - MAC address
 - ARP


## 概要


## L2転送の概要

ネットワークを流れるパケットは複数のプロトコルのヘッダを持っていて、
各プロトコルは決められた役割に使われます。
本ページで扱うのは図のL2にあたる「**イーサネット**」と呼ばれるプロトコルです。
イーサネット以外にもL2のプロトコルは存在しますが、
現在のネットワークはイーサネット以外を利用することは稀です。

![image](./0010_image/01.png)

イーサネットが利用するアドレスはIPアドレスではなく、「**MACアドレス**」です。
MACアドレスは16進数が12桁ですので16の12乗パターン、つまり「2の48乗」パターンの表現ができることになります。
実際は全てが利用できるわけではありませんが、IPアドレスの「2の32乗」パターンより多くのアドレスを使うことができます。
L2プロトコルとしてイーサネットを使うインターフェースは、設定することができるIPアドレスに加えて、
製造ベンダが設定したMACアドレスを持ちます。

異なるネットワーク間のパケット転送にはIPアドレスを基準にしたL3転送がおこなわれますが、
同一ネットワーク内のパケット転送にはMACアドレスを利用したL2転送が使われます。
同一ネットワーク内でL2転送をおこなう「**スイッチ**」という機器は、
どこのインターフェースの先にどういったMACアドレスを持つ機器がいるかを記憶しており、
そのアドレス宛のフレーム(L2転送されるデータ)を受け取ったらそちらに転送をします。

ただ、たとえば自宅のネットワークでプリンタやNASを利用する際に、
それらの機器をどのように指定するかというとIPアドレスです。
プリントするデータやダウンロードするファイルのやりとりはMACアドレスを利用したL2転送をしますので、
相手のIPアドレスから通信に使うMACアドレスを特定できる必要があります。
これには「**ARP(Address Resolution Protocol)**」というプロトコルを利用します。

ここまでの話をまとめると、同一ネットワーク内の機器同士の通信は以下の手順でおこなわれます。

0. IPアドレスで相手の機器を指定する
0. ARPでIPアドレスからMACアドレスを取得する
0. ホストは相手のMACアドレス宛にフレームを送信する
0. スイッチは相手のMACアドレスが接続されるポートへフレームを転送
0. 宛先の機器はフレームを受け取る

以後の本ページではこの流れの詳細を実際に機器を操作しながら確認します。
どのようにARPが利用され、どのようにスイッチがフレームを宛先に転送するか。

### ユニキャストとブロードキャスト

MACアドレスを使ったL2の転送には2種類あります。

「**ユニキャスト**」と呼ばれる特定の宛先に対する通信と、
「**ブロードキャスト**」と呼ばれる全ての宛先に対する通信です。

ユニキャストは「特定のホストから特定のホスト」にデータを届けるための通信なので、
フレームは宛先に辿り着くための一本の経路を使ってデータを送ります。
同じネットワーク内のプリンターやNASを使う場合はユニキャストを使っており、
他のほとんどの通信もユニキャストです。

ブロードキャストは「不特定多数のホスト」に対する通信です。
ユニキャストのように特定の相手に対して通信を行うというよりは、
「この情報を知っている人はいますか」と同一ネットワーク全体に対して問い合わせを行うような場面で使われます。
ブロードキャスト用の特別な宛先MACアドレス「**FFFF.FFFF.FFFF**」を使うと、
それを受け取ったL2スイッチは受け取ったポートを除く全ての他のポートからそのフレームを送ります。
この動きを繰り返すことで、同じネットワークに属する全てのホストにフレームを届けることができます。

![image](./0010_image/01.png)

ブロードキャストに似たものに「**マルチキャスト**」というものがありますが、
L2のフレーム転送においてはブロードキャストと大差はありません。
ただ、そのフレームを受け取ったホストがブロードキャストであれば無条件にフレームの内容をチェックするのに対し、
マルチキャストだとそのホストが関心があるアドレス宛以外のものは全て破棄(無視)します。



## 機器の設定

### 構成図

本ページではL2転送を試すためにスイッチに複数のホストが接続されているという構成を作ります。

![image](./0010_image/01.png)

この構成にはルーターが存在しないため、
異なるネットワークに接続することはできません。
ただ、同一ネットワーク内の通信にはルーターは利用されないため、
ホストとホストを結ぶスイッチのみで通信が完了します。

なお、本来であればホストにWindowsやLinuxを利用するのでしょうが、
本サイトではCiscoのルーターをホストとして使います。
他のホストからのパケットの転送などはさせずに、単純に送信元ホスト及び宛先ホストとして使います。

一般的なホストに設定するネットワークの設定はIPアドレスとサブネットマスクに加えてデフォルトゲートウェイとなります。
ただ、デフォルトゲートウェイは「異なるネットワークへの通信を誰に中継させるか」という設定ですので、
今回は不要となります。

スイッチやホストの学習状況の確認をやりにくいため、
MACアドレスを任意の値に変更します。
MACアドレスを変更するのはトラブルのもとですので、特別な理由がないかぎりは変更をしないでください。


### ホストへのIPアドレス及びMACアドレスの設定

CiscoのルーターではIPアドレスだけでなくMACアドレスの変更をすることも可能です。
それにはインターフェースコンフィグモードで「mac-address <MACアドレス>」とします。
IPアドレスとともに設定し、インターフェースをupさせます。

```text
PC1#conf t  
PC1(config)#int g0/1
PC1(config-if)#ip addr 10.0.0.101 255.0.0.0
PC1(config-if)#mac-address 0000.0000.0101
PC1(config-if)#no shut
PC1(config-if)#end
```

MACアドレスはネットワークのインターフェース(ポート)に設定されています。
IPアドレスと違って初期値を持っているため、特に設定を加えていなくてもMACアドレスは設定されています。

```text
PC1#show int g0/1
GigabitEthernet0/1 is up, line protocol is up
  Hardware is iGbE, address is 0000.0000.0101 (bia fa16.3e1f.a079)  <=== MAC ADDRESS
  Internet address is 10.0.1.101/24                                 <=== IP ADDRESS
  MTU 1500 bytes, BW 1000000 Kbit/sec, DLY 10 usec,
     reliability 255/255, txload 1/255, rxload 1/255
  Encapsulation ARPA, loopback not set
  Keepalive set (10 sec)
  Auto Duplex, Auto Speed, link type is auto, media type is RJ45
以下省略
```

先ほど設定したMACアドレス「0000.0000.0101」が設定されています。
その右側にあるものはデフォルト値で、MACアドレスに任意の値を設定しなければこの値がMAC値として利用されます。
16進数12桁のMACアドレスは前半が「**ベンダーコード**」というどこの製品かを示すものとなっています。
たとえば私が使っているMacのMACアドレスは「b8:e8:56:3c:67:36」となっており、
「b8:e8:56」で検索すると「vendor name : Apple」とでてきました。
上記のサンプル出力のMACアドレスはシミュレーター内のものであるため、
ベンダーは存在しません。


## スイッチでのL2転送の仕組み

### L2フレームの構造

ユニキャスト通信では送信元ホストが宛先ホストのMACアドレスあてにフレームを送信します。
このフレームのL2ヘッダはイーサネットの形式ですので、
以下のような構造となっています。

![image](./0010_image/01.png)

図では省略していますが、宛先MACの前には「プリアンブル」と呼ばれる決まった01の組合せがあります。
これは電気信号や光信号で「ここからフレームが始まりますよ」と分かるための目印のようなものです。
転送などには大きく関わらないため、通常時は無視して構いません。

プリアンブルに続く「**宛先MACアドレス**」および「**送信元MACアドレス**」がL2転送において重要な役割を持ちます。
宛先MACアドレスは宛先ホストのアドレスとなっていて、
スイッチはこれを基準に転送するポートを決めます。
また、送信元MACアドレスがあることで、宛先ホストや中継するスイッチが誰が送ってきたフレームかを判別することができます。

それに続く「**タイプ**」はイーサネットフレームがどういったデータをカプセル化しているかということを示すためのものです。
TCP/IPではマトリョーシカ人形のようにレイヤを下るごとにヘッダを追加していきますが、
上のレイヤのデータを確認する際にどういったプロトコルを使っているかが下のレイヤのヘッダに書かれていると処理しやすいです。
たとえばタイプが「データはIPですよ」と示していれば、IPの処理に渡して、
「データはARPですよ」と示していればARPの処理に渡せばよいことがわかります。

最後にある「**FCS**」はフレームが壊れていないことを確認するためのものです。
データ信号や光信号が外部からの影響で狂ってしまった場合に、FCSとデータを比較することで壊れていることが検知できます。


### MACアドレステーブル

スイッチは渡されたフレームの宛先MACアドレスを確認することで、
どのホストに届ければいいか判断できます。

どのホストに届ければいいか判断するということはつまり、
どのポートからパケットを転送すればいいか判断するということです。
この転送の判断をするためには「どのポートの先にどのMACアドレスを持つ機器が存在するか」ということをスイッチが知っている必要があります。
これをするための情報が「**MACアドレステーブル**」です。

![image](./0010_image/03a.png)

MACアドレステーブルはMACアドレスとポートの組合せの表です。
どのアドレスはどのポートの先にあるかを表として持つため、
フレームを受け取った際に宛先アドレスを調べることでどのポートから送ればいいかを判断できます。
たとえばPC1からPC2に送られたフレームを送ったとすると、
スイッチでは宛先MACが「0000.0000.0102」のフレームをポートg0/1ポートで受け取ることになります。
スイッチは宛先MACとMACアドレステーブルを比較することで、「0000.0000.0102」がポートg0/2の先にいることが分かります。
そのためスイッチはフレームをポートg0/2から送信し、ホストであるPC2はそれを受け取ることができます。

スイッチでMACアドレステーブルを確認するには管理者モードで「**show mac address table**」コマンドを使います。

```text
S1#show mac address-table
          Mac Address Table
-------------------------------------------

Vlan    Mac Address       Type        Ports
----    -----------       --------    -----
   1    fa16.3e1f.a079    DYNAMIC     Gi0/1
   1    fa16.3e7f.78a1    DYNAMIC     Gi0/2
```

出力にはVLAN、MACアドレス、タイプ、ポートという項目があります。
VLANは後述するグループ分けの機能でどのグループに属するかということを示していて、
タイプはどのようにして学習したかということを示しています。
それ以外は既に説明したとおりとなっています。

MACアドレステーブルは人の手で「このポートの先にこのMACアドレスがある」と設定するのではなく、
MACアドレス学習という仕組みを使って自動で作成されます。


### MACアドレス学習

スイッチのポートは多数あり、スイッチの先にスイッチがあるという構成だとひとつのポートの先にある機器も多数となります。
そのような状況でスイッチに「このポートの先に、このMACアドレスを持つ機器があります」と全て設定していくことは現実的ではありません。
また、たとえそのようなことができたとしても配線の変更などのたびに大量のMACアドレスの登録変更をすることは難しく、
設定ミスによるトラブルなどが頻発することが予想されます。
このような背景からスイッチはMACアドレステーブルを自動で構築します。

![image](./0010_image/03a.png)

イーサネットのフレームには宛先MACアドレスだけでなく、送信元MACアドレスがあります。
スイッチはフレームをポートで受け取った際に、「この受け取ったポートの先に、送信元MACアドレスのMACアドレスを持つホストが存在する」と分かります。
そしてMACアドレステーブルにその情報を書き込みます。
先の例だとPC1からPC2にフレームを送った時に「スイッチのポートg0/1で送信元MACアドレス0000.0000.0101を受け取る」ことが発生しますが、
このタイミングでMACアドレステーブルに「ポートg0/1の先にはMACアドレス0000.0000.0101のホストがある」と登録します。
すでに同じ情報がMACアドレステーブルにある場合は特に変更は発生しません。

このフレームを受け取った際に送信元MACアドレスからMACアドレステーブルのエントリを作る仕組は
「**MACアドレス学習**」と呼ばれています。
フレームの転送は宛先MACアドレスを基準にしておこなわれるのにたいして、
学習は送信元MACアドレスが基準となります。
よく勘違いしているエンジニアがいるので注意をしてください。


### MACアドレスの削除と更新

学習したMACアドレスの機器がそのポートの先に存在するということは、
永久に保証できるものではありません。
たとえばPC1をスイッチのポートg0/1からg0/4につなぎかえたら、
MACアドレステーブルのエントリである「0000.0000.0101 : g0/1」は誤った情報となり、
正しくは「0000.0000.0101 : g0/4」となります。

MACアドレステーブルの情報を正しく保つためには、
エントリを登録するだけでなく消したり更新したりすることが欠かせません。

機器がそのポートの先に存在しなくなると判断できるのは、
そのポートがダウン状態になった場合です。
ポートからフレームを送信できなため、そのポートとMACアドレスを紐付けておく必要はありません。

もうひとつは長期間通信が発生しなかった場合です。
「ホスト -> スイッチA -> スイッチB」という構成だと、
ホストがスイッチAに接続するケーブルを抜いて別の場所に動いても、直接接続されていないホストBはそれを知りません。
ずっとホストがスイッチAの先にいると思ってフレームをスイッチA側に転送し続けてしまうことを防ぐために、
スイッチBはスイッチAから「送信元MACアドレスがホストとなっているフレーム」を一定時間受け取らなければ、
ホストのMACアドレスのエントリをMACアドレステーブルから削除します。
このような状況のことを「タイムアウト」と呼んでいます。
一般的には5分が設定されています。

上記のスイッチBの状況で、タイムアウトが発生するまえにホストの送信元MACアドレスを持つフレームが別のポートからくれば、
MACアドレスのエントリはタイムアウトを待つこと無く新しいアドレスとポートのペアで更新されます。
フレームが届くということは、その受信ポートの先に送信元MACアドレスを持つ機器がいるということが確実だからです。

よくある障害としては同一MACアドレスを持つ機器がネットワークに2つあり、
それらがフレームを送り続けることでMACアドレスのテーブルのエントリが不安定になるというものがあります。
通称、MACフラップと呼ばれるもので、手動で機器にMACアドレスを設定するのに不備があると発生します。


### アンノウンユニキャストによるフラッディング

フレームはスイッチが持つMACアドレステーブルの情報に従って転送されます。
テーブルにエントリがあればどのポートから出せばいいか判断できますが、
まだスイッチがアドレスを学習していない場合はどのポートを使えばいいか分かりません。

このような状況では「フレームを受け取った以外の全てのポートからフレームを出す」という動きをします。
ようするに「同一ネットワーク全体に対して送ってしまえば、どこかにいるから届くだろう」という考えかたです。
宛先アドレスがどこにいるか分からないユニキャストの通信のことを「**アンノウンユニキャスト**」と呼び、
アンノウンユニキャストのフレームを拡散する動きのことを「**フラッド**」と呼びます。

一般的にネットワークの通信は2つのホストがお互いにデータを送り合います。
データをダウンロードするような片方向の通信であっても、
TCP/IPの仕組みが効いてダウンロードしている側も「データはきちんと届いていますよ」とメッセージを送り返します。
そのため、フレームの宛先から送信元にたいする逆方向の通信も発生しますので、
そのうちMAC学習がきちんとなされます。

ただ、存在しないMACアドレスに対して延々と大量のデータを送り続けると、
それはネットワーク内でずっとフラッドし続けてしまいます。
一般的なアプリケーションはそのような動きはしませんが、
悪意を持って攻撃されると問題箇所のポートを閉じるといった対応が必要になります。


## ARP

あるホストが別のホストにデータを送信しようとした場合は宛先ホストをIPで指定します。
自動で検出できないネットワークプリンタを使おうと思えばIPで登録する必要がありますし、
NASなどに接続しようと思えばIPを入力します。

同一ネットワーク内のフレームの転送にはMACアドレスを利用するものの、
相手の特定にはIPアドレスを利用します。


データを送る際に必要となる宛先のIPは特定できていますが、
IPを指定しただけでは相手のMACアドレスは特定できていません。
「**ARP(Address Resolution Protocol)**」はこれをするためのプロトコルで、
宛先IPを指定すれば宛先MACアドレスを取得してきます。

### ARPリクエスト

同一ネットワーク内でパケットをやりとりする場合はMACアドレスを使うのでした。
ただ、それをするためにはPCが「相手のMAC」アドレスを知ったり、
ホストとホストの間にいるスイッチが「どのインターフェースの先にどのMACアドレスを持つ機器がいるか」というMACアドレステーブルを更新する必要があります。

本章ではPC1からPC2に対してPingをしましたが、その際に指定した宛先はPC2のIPアドレスです。
通常は機器と機器が通信をする際は、相手をIPアドレスで指定します。
ただ、同じネットワーク内の転送にはMACアドレスが利用されます。
そのため、IPアドレスからMACアドレスを求める仕組みが必要となり、ARPという仕組みがそれを実現しています。

<<図>>

PC1がPC2に通信をする際に、まずARPを使って「192.168.0.102のアドレスを持つ人は応答して下さい」と特殊なパケットを投げます。
このパケットはスイッチで受け取ったポートを除く全てのポートに対して拡散されますので、これがPC2とPC3に届きます。
PC3はそのARPを見て「これは私のIPではないな。無視」として応答しませんが、PC2は「私のIPアドレスだ。応答しよう」となり、
ARPに対して応答します。

### ARPリプライ

この応答にはMACアドレスが含まれているため、それを受け取ったPC1は「IPが192.168.0.102の機器のMACアドレスはXXXXだ」と分かり、
PC2に対してパケットを送ることができるようになります。

### ARPテーブル


1パケット送るごとにこのようなことをやっていると非効率ですので、PC1はこの結果をしばらく覚えておき、
継続する通信ではARPは発生しません。
この覚えていることを「**ARPテーブル**」や「**ARPキャッシュ**」と呼びます。

![image](./0010_image/03a.png)

ただ、定められた一定時間の間にPC2と通信をしないと、
このキャッシュは消されます。
これはIPとMACアドレスの対応関係が永遠に続くとは限らないためです。
例えば新しい機器に、すでに取り外された機器のIPアドレスを与えた際に、
昔の機器のMACアドレス宛にパケットを送り続けたら困りますよね。


ARPの学習状況がどのようになっているかは以下のコマンドで確認できます。

```text
PC1#show ip arp  
Protocol  Address          Age (min)  Hardware Addr   Type   Interface
Internet  10.0.1.101              -   fa16.3e1f.a079  ARPA   GigabitEthernet0/1
Internet  10.0.1.102              3   fa16.3e7f.78a1  ARPA   GigabitEthernet0/1
```

ARP解決後は学習されている

```text
PC1#ping 10.0.1.103
Type escape sequence to abort.
Sending 5, 100-byte ICMP Echos to 10.0.1.103, timeout is 2 seconds:
.!!!!
Success rate is 80 percent (4/5), round-trip min/avg/max = 4/4/5 ms

PC1#show ip arp    
Protocol  Address          Age (min)  Hardware Addr   Type   Interface
Internet  10.0.1.101              -   fa16.3e1f.a079  ARPA   GigabitEthernet0/1
Internet  10.0.1.102              6   fa16.3e7f.78a1  ARPA   GigabitEthernet0/1
Internet  10.0.1.103              0   fa16.3e18.af47  ARPA   GigabitEthernet0/1

PC1#ping 10.0.1.103
Type escape sequence to abort.
Sending 5, 100-byte ICMP Echos to 10.0.1.103, timeout is 2 seconds:
!!!!!
Success rate is 100 percent (5/5), round-trip min/avg/max = 2/3/5 ms
```


### 大きなネットワークの構築

1つのネットワークに接続する機器が全て同じスイッチに接続されているとは限りません。
スイッチはネットワークを拡張する役割があるので、スイッチにスイッチを繋げるとより大きなネットワークを作ることができます。
業務用のスイッチの多くは24ポートもしくは48ポートですので、大きな部署で人数分のPCとIP電話を繋げばすぐにポートを使い尽くしてしまいます。
そのような時はスイッチを木構造で繋げることで大きな一つのネットワークを作ります。
例えば以下のような上位のスイッチ(スイッチを繋げるためのスイッチ)に下位のスイッチ(ユーザーを繋げるスイッチ)を繋げるという構造です。

![image](./0010_image/03a.png)

ユーザが増えれば上位スイッチに繋げる下位スイッチを増やせばいいですし、それでも足りなければ階層構造を3つに増やせます。
実際はこの階層化に加えて冗長化技術(機器が壊れてもネットワークを提供し続けられる)も使いますが、それは後ほど扱います。

先ほどの1つのスイッチの構成と、スイッチを多段に繋げた構成ではMACアドレステーブルの学習内容が異なります。
PCを繋げたポートは1つのMACアドレスしか学習しませんが、スイッチを繋げたポートはその先にいる機器の複数のMACアドレスを学習します。
つまりMACアドレステーブルではポートとMACアドレスの対応関係が「1:1」ではなく、「1:多」となります。
PCが繋がるポートも同じで、特別なソフトウェアなどで複数のMACアドレスを使うと、スイッチのポートは複数のMACアドレスを学習します。

実際に以下の構成をVIRLで作成して、MACアドレスを確認してみます。

MACアドレスを変更したうえで、PC1,2,3の間でPingを発行し、MACアドレスをスイッチに学習させています。
各スイッチのMACアドレスの学習状況は以下のようになりました。

![image](./0010_image/03a.png)

S1はPC3をS3を経由して学ぶため、PC3のMACは「S3が接続されているG0/3インタフェース」で学んでいます。
S2スイッチはPC1,2をS3を経由して学ぶため、S3が接続されるG0/2で2つのPCを学習しています。
S3はS1に接続される2つのPCのMACをS1が接続されるG0/1で学び、PC3はG0/2で学んでいます。

各スイッチの実際のMACテーブルは以下のようなものとなっていました。

```text
S1#show mac address-table          
          Mac Address Table
-------------------------------------------

Vlan    Mac Address       Type        Ports
----    -----------       --------    -----
   1    0000.0000.0101    DYNAMIC     Gi0/1
   1    0000.0000.0102    DYNAMIC     Gi0/2
   1    0000.0000.0103    DYNAMIC     Gi0/3
   1    fa16.3e3a.db08    DYNAMIC     Gi0/3
   1    fa16.3e56.0961    DYNAMIC     Gi0/3


S2#show mac address-table          
         Mac Address Table
-------------------------------------------

Vlan    Mac Address       Type        Ports
----    -----------       --------    -----
   1    0000.0000.0101    DYNAMIC     Gi0/2
   1    0000.0000.0102    DYNAMIC     Gi0/2
   1    0000.0000.0103    DYNAMIC     Gi0/1
   1    fa16.3e3a.a66a    DYNAMIC     Gi0/2
   1    fa16.3ea4.4f78    DYNAMIC     Gi0/2

S3#show mac address-table
         Mac Address Table
-------------------------------------------

Vlan    Mac Address       Type        Ports
----    -----------       --------    -----
   1    0000.0000.0101    DYNAMIC     Gi0/1
   1    0000.0000.0102    DYNAMIC     Gi0/1
   1    0000.0000.0103    DYNAMIC     Gi0/2
   1    fa16.3e56.0961    DYNAMIC     Gi0/2
   1    fa16.3ea4.4f78    DYNAMIC     Gi0/1      
```

上記のテーブルにはPC以外のMACアドレスも学習されていますが、
これはスイッチのインターフェースに割り当てられているものです。
例えばS2とS3が学習している「fa16.3ea4.4f78」は、S1のG0/3インタフェースのMACアドレスです。

```text
S1#show int g0/3 | inc address
  Hardware is iGbE, address is fa16.3ea4.4f78 (bia fa16.3ea4.4f78)
```

実はスイッチ間ではIPパケット以外にもお互いの機器情報の交換といった様々な通信が行われています。
それもMACアドレスを使って届け合うため、MAC学習されてMACテーブルにのってきます。
実際に運用をする際はMACアドレステーブルを気にすることはほとんどありませんが、
なにかトラブルが発生した場合は対象のMACアドレスがどこでどのように学習されているか調べることで問題解決の糸口が見つかる可能性があります。

### 大きなネットワークの問題点

さて、大きなネットワークセグメントを使えば多数の機器を繋げることが分かりました。
理屈としてはスイッチにスイッチを繋げていけば世界中のPCを繋げたネットワークが作れそうな気がしますが、
なぜそうなっていないと思いますか。

これにはいくつかの理由があります。
まず、ARPの動き(ブロードキャスト)を思い出して下さい。
あれはネットワーク全てに拡散されます。
もし1つのネットワークに接続された1億台のPCが互いにARPを投げあったら、ARPだけでネットワークは埋め尽くされて、
PCもARPへの応答(無視するか返信するか)処理でいっぱいいっぱいになってしまいます。
この問題を防ぐためにネットワークを必要以上に大きくすることはできません。

次の問題はMACアドレステーブルの大きさです。
今回の実験を通して分かったと思いますが、MACテーブルのエントリの数はおおよそネットワークに属する機器の数と同じになります。
スイッチがフレームを受け取った際にどこの出口から出せばいいかということを管理していますが、
高速な転送をするために転送チップに直接エントリを書くためそれほど多くの学習はできません。
MACテーブルの上限値を超えたフレームの学習はできないため、なにかを忘れる必要があり、
それが再びアンノウンユニキャストによるフラッディングを導いてしまいます。

大きなネットワークを作らないのは、障害を局所化するという意味合いもあります。
たとえば部署ごとにネットワークを切っていれば、ある部署の障害はその部署に閉じます。
一方、社内全員が同じネットワークに属していれば、障害は全社規模となってしまいます。

他には同じネットワーク内にある機器同士の通信を制御しにくいという問題点もあります。
機器は移動しますので、どのスイッチのどのポートに接続するかということは強く縛ることが難しいです。
そのような状況でお客さんと社員が同じネットワークに参加していると、
社外秘のファイルを持つサーバーが見えてしまったり、プリンターが勝手に使われてしまうという問題が起きるかもしれません。
お客さん用のネットワークと社員のネットワークを分離すれば、お客さんが社員用のネットワークにアクセスできないようにすれば済むだけです。

事象では複数のネットワークを繋ぐルーターの役割について扱います。

### コラムL2の機器

スイッチ
 - port
 - uplink

wifi
 - switchに接続
 - コントローラー
